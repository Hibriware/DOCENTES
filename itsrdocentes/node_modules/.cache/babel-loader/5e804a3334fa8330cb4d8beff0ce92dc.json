{"ast":null,"code":"import toDate from '../toDate/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js';\n/**\r\n * @name parseJSON\r\n * @category Common Helpers\r\n * @summary Parse a JSON date string\r\n *\r\n * @description\r\n * Converts a complete ISO date string in UTC time, the typical format for transmitting\r\n * a date in JSON, to a JavaScript `Date` instance.\r\n *\r\n * This is a minimal implementation for converting dates retrieved from a JSON API to\r\n * a `Date` instance which can be used with other functions in the `date-fns` library.\r\n * The following formats are supported:\r\n *\r\n *     - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`\r\n *     - `2000-03-15T05:20:10Z`: Without milliseconds\r\n *     - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages\r\n *     - `2000-03-15T05:20:10+0000`: With a zero offset without a colon\r\n *     - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol\r\n *     - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds\r\n *     - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting\r\n *\r\n * For convenience and ease of use these other input types are also supported\r\n * via [toDate]{@link https://date-fns.org/docs/toDate}:\r\n *\r\n *     - A `Date` instance will be cloned\r\n *     - A `number` will be treated as a timestamp\r\n *\r\n * Any other input type or invalid date strings will return an `Invalid Date`.\r\n *\r\n * @param {String|Number|Date} argument A fully formed ISO8601 date string to convert\r\n * @returns {Date} the parsed date in the local time zone\r\n * @throws {TypeError} 1 argument required\r\n */\n\nexport default function parseJSON(argument) {\n  requiredArgs(1, arguments);\n\n  if (typeof argument === 'string') {\n    var parts = argument.match(/(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{0,7}))?(?:Z|\\+00:?00)?/);\n\n    if (parts) {\n      return new Date(Date.UTC(+parts[1], parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +((parts[7] || '0') + '00').substring(0, 3)));\n    }\n\n    return new Date(NaN);\n  }\n\n  return toDate(argument);\n}","map":{"version":3,"sources":["E:/Certificados/heroku/docentestoken/DOCENTES/itsrdocentes/node_modules/date-fns/esm/parseJSON/index.js"],"names":["toDate","requiredArgs","parseJSON","argument","arguments","parts","match","Date","UTC","substring","NaN"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,oBAAnB;AACA,OAAOC,YAAP,MAAyB,+BAAzB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,eAAe,SAASC,SAAT,CAAmBC,QAAnB,EAA6B;AAC1CF,EAAAA,YAAY,CAAC,CAAD,EAAIG,SAAJ,CAAZ;;AAEA,MAAI,OAAOD,QAAP,KAAoB,QAAxB,EAAkC;AAChC,QAAIE,KAAK,GAAGF,QAAQ,CAACG,KAAT,CAAe,mFAAf,CAAZ;;AAEA,QAAID,KAAJ,EAAW;AACT,aAAO,IAAIE,IAAJ,CAASA,IAAI,CAACC,GAAL,CAAS,CAACH,KAAK,CAAC,CAAD,CAAf,EAAoBA,KAAK,CAAC,CAAD,CAAL,GAAW,CAA/B,EAAkC,CAACA,KAAK,CAAC,CAAD,CAAxC,EAA6C,CAACA,KAAK,CAAC,CAAD,CAAnD,EAAwD,CAACA,KAAK,CAAC,CAAD,CAA9D,EAAmE,CAACA,KAAK,CAAC,CAAD,CAAzE,EAA8E,CAAC,CAAC,CAACA,KAAK,CAAC,CAAD,CAAL,IAAY,GAAb,IAAoB,IAArB,EAA2BI,SAA3B,CAAqC,CAArC,EAAwC,CAAxC,CAA/E,CAAT,CAAP;AACD;;AAED,WAAO,IAAIF,IAAJ,CAASG,GAAT,CAAP;AACD;;AAED,SAAOV,MAAM,CAACG,QAAD,CAAb;AACD","sourcesContent":["import toDate from '../toDate/index.js';\r\nimport requiredArgs from '../_lib/requiredArgs/index.js';\r\n/**\r\n * @name parseJSON\r\n * @category Common Helpers\r\n * @summary Parse a JSON date string\r\n *\r\n * @description\r\n * Converts a complete ISO date string in UTC time, the typical format for transmitting\r\n * a date in JSON, to a JavaScript `Date` instance.\r\n *\r\n * This is a minimal implementation for converting dates retrieved from a JSON API to\r\n * a `Date` instance which can be used with other functions in the `date-fns` library.\r\n * The following formats are supported:\r\n *\r\n *     - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`\r\n *     - `2000-03-15T05:20:10Z`: Without milliseconds\r\n *     - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages\r\n *     - `2000-03-15T05:20:10+0000`: With a zero offset without a colon\r\n *     - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol\r\n *     - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds\r\n *     - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting\r\n *\r\n * For convenience and ease of use these other input types are also supported\r\n * via [toDate]{@link https://date-fns.org/docs/toDate}:\r\n *\r\n *     - A `Date` instance will be cloned\r\n *     - A `number` will be treated as a timestamp\r\n *\r\n * Any other input type or invalid date strings will return an `Invalid Date`.\r\n *\r\n * @param {String|Number|Date} argument A fully formed ISO8601 date string to convert\r\n * @returns {Date} the parsed date in the local time zone\r\n * @throws {TypeError} 1 argument required\r\n */\r\n\r\nexport default function parseJSON(argument) {\r\n  requiredArgs(1, arguments);\r\n\r\n  if (typeof argument === 'string') {\r\n    var parts = argument.match(/(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{0,7}))?(?:Z|\\+00:?00)?/);\r\n\r\n    if (parts) {\r\n      return new Date(Date.UTC(+parts[1], parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +((parts[7] || '0') + '00').substring(0, 3)));\r\n    }\r\n\r\n    return new Date(NaN);\r\n  }\r\n\r\n  return toDate(argument);\r\n}"]},"metadata":{},"sourceType":"module"}